import os
import time
import logging
import pandas as pd
from faker import Faker
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from datetime import datetime
from dotenv import load_dotenv
from ftplib import FTP, error_perm

load_dotenv()

INPUT_FOLDER = "./excel_drop"
OUTPUT_FOLDER = "./output_text"
LOG_FILE = "ftp_upload.log"

FTP_HOST = "ftp.example.com"
FTP_USER = "your_username"
FTP_PASS = "your_password"
FTP_BASE_DIR = "/upload"

os.makedirs(INPUT_FOLDER, exist_ok=True)
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

faker = Faker()

# Configure logging
logging.basicConfig(filename=LOG_FILE, level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")

def parse_excel(path):
    df = pd.read_excel(path, header=None)
    columns = df.iloc[0].tolist()
    types = df.iloc[1].tolist()
    return columns, types

def generate_fake_row(columns, types, date_format, start_year, end_year, fixed_lengths, entity_prc_values):
    row = []
    for col, typ in zip(columns, types):
        typ_lower = typ.lower()
        if "entity_prc" in col.lower() and entity_prc_values:
            row.append(faker.random_element(entity_prc_values))
        elif "date" in typ_lower or "timestamp" in typ_lower:
            start_date = datetime(start_year, 1, 1)
            end_date = datetime(end_year, 12, 31)
            dt = faker.date_time_between(start_date=start_date, end_date=end_date)
            if "timestamp" in typ_lower:
                row.append(dt.strftime("%Y-%m-%d %H:%M:%S.%f")[:-3])
            else:
                row.append(dt.strftime(date_format))
        elif "int" in typ_lower:
            val = str(faker.random_int(min=0, max=999999))
            row.append(val.zfill(fixed_lengths.get(col, 0)) if col in fixed_lengths else val)
        elif "float" in typ_lower or "decimal" in typ_lower:
            val = f"{round(faker.pyfloat(left_digits=5, right_digits=2, positive=True), 2)}"
            row.append(val)
        else:
            fake_str = faker.word()
            max_len = fixed_lengths.get(col)
            if max_len:
                fake_str = fake_str[:max_len].ljust(max_len, "_")
            row.append(fake_str)
    return row

def generate_unique_data(columns, types, count, date_format, start_year, end_year, pk_indices, fixed_lengths, entity_prc_values):
    data = []
    seen_keys = set()
    attempts = 0
    max_attempts = count * 10

    while len(data) < count and attempts < max_attempts:
        row = generate_fake_row(columns, types, date_format, start_year, end_year, fixed_lengths, entity_prc_values)
        key = tuple(row[i] for i in pk_indices)
        if key not in seen_keys:
            seen_keys.add(key)
            data.append(row)
        attempts += 1

    if len(data) < count:
        print(f"âš ï¸ Warning: Only generated {len(data)} unique rows out of requested {count}.")
    return data

def upload_to_ftp(local_file_path, remote_file_name, subfolder=None):
    try:
        with FTP(FTP_HOST) as ftp:
            ftp.login(user=FTP_USER, passwd=FTP_PASS)
            ftp.cwd(FTP_BASE_DIR)

            if subfolder:
                try:
                    ftp.cwd(subfolder)
                except error_perm:
                    print(f"ðŸ“ Subfolder '{subfolder}' not found. Creating it...")
                    ftp.mkd(subfolder)
                    ftp.cwd(subfolder)

            with open(local_file_path, "rb") as f:
                ftp.storbinary(f"STOR {remote_file_name}", f)
            
            message = f"âœ… Uploaded '{remote_file_name}' to FTP folder '{subfolder or FTP_BASE_DIR}'"
            print(message)
            logging.info(message)
    except Exception as e:
        message = f"âŒ FTP Upload failed for '{remote_file_name}': {e}"
        print(message)
        logging.error(message)

class ExcelHandler(FileSystemEventHandler):
    def on_created(self, event):
        if not event.is_directory and event.src_path.endswith(".xlsx"):
            file_path = event.src_path
            print(f"\nðŸ“¥ New Excel file detected: {file_path}")
            try:
                columns, types = parse_excel(file_path)
                print(f"Columns: {columns}")
                print(f"Types: {types}")

                num_rows = int(input("ðŸ”¢ How many rows of data should be generated? "))
                date_format = input("ðŸ“† What date format should be used? (e.g. %Y-%m-%d, %d/%m/%Y): ")
                delimiter = input("ðŸ”£ What character should be used as a delimiter between rows? (e.g. ',' or ';' or '|'): ")
                start_year = int(input("ðŸ“… Start year for date fields? "))
                end_year = int(input("ðŸ“… End year for date fields? "))

                print("ðŸ—ï¸ Columns:")
                for idx, name in enumerate(columns):
                    print(f"{idx}: {name}")
                pk_input = input("ðŸ”‘ Enter comma-separated column numbers that form the Primary Key (e.g., 0,2): ")
                pk_indices = [int(i.strip()) for i in pk_input.split(",") if i.strip().isdigit()]

                # Prompt for ENTITY_PRC values
                entity_prc_values = []
                if "ENTITY_PRC" in columns:
                    val_input = input("ðŸ·ï¸ Enter comma-separated values for ENTITY_PRC (they'll be randomly used): ")
                    entity_prc_values = [v.strip() for v in val_input.split(",") if v.strip()]

                # Prompt for fixed lengths
                fixed_lengths = {}
                for col, typ in zip(columns, types):
                    if "date" in typ.lower() or "timestamp" in typ.lower():
                        continue
                    resp = input(f"ðŸ“ Enter fixed length for column '{col}' (or press Enter to skip): ")
                    if resp.strip().isdigit():
                        fixed_lengths[col] = int(resp.strip())

                out_filename = input("ðŸ’¾ How should the output file be named? (skip to auto-name): ")
                if not out_filename:
                    out_filename = os.path.basename(file_path).replace(".xlsx", "_out.txt")
                if not out_filename.endswith(".txt"):
                    out_filename += ".txt"
                output_path = os.path.join(OUTPUT_FOLDER, out_filename)

                print("ðŸ¤– Generating data...")
                rows = generate_unique_data(columns, types, num_rows, date_format, start_year, end_year, pk_indices, fixed_lengths, entity_prc_values)

                if not rows:
                    print("âŒ No data generated. Skipping file.")
                    return

                df = pd.DataFrame(rows, columns=columns)
                df.to_csv(output_path, index=False, sep=delimiter, lineterminator="\n")
                print(f"âœ… Data saved to {output_path}")

                # Ask about FTP subfolder
                use_subfolder = input("ðŸ“¤ Do you want to upload to a specific subfolder on the FTP server? (y/n): ").strip().lower()
                ftp_subfolder = None
                if use_subfolder == "y":
                    ftp_subfolder = input("ðŸ“‚ Enter the subfolder name to upload to: ").strip()
                    if not ftp_subfolder:
                        ftp_subfolder = None

                upload_to_ftp(output_path, out_filename, ftp_subfolder)

            except Exception as e:
                print(f"âŒ Error processing file: {e}")
                logging.error(f"âŒ Processing error for file {file_path}: {e}")

def main():
    print(f"ðŸ“‚ Watching folder: {INPUT_FOLDER}")
    observer = Observer()
    observer.schedule(ExcelHandler(), INPUT_FOLDER, recursive=False)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

if __name__ == "__main__":
    main()
