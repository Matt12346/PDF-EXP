import os
import time
import pandas as pd
from faker import Faker
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from datetime import datetime
from dotenv import load_dotenv
from ftplib import FTP

load_dotenv()

INPUT_FOLDER = "./excel_drop"
OUTPUT_FOLDER = "./output_text"

FTP_HOST = "ftp.yourserver.com"
FTP_USER = "your_username"
FTP_PASS = "your_password"
FTP_TARGET_DIR = "/path/to/target/folder"

os.makedirs(INPUT_FOLDER, exist_ok=True)
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

faker = Faker()

def parse_excel(path):
    df = pd.read_excel(path, header=None)
    columns = df.iloc[0].tolist()
    types = df.iloc[1].tolist()
    return columns, types

def upload_via_ftp(local_file_path, remote_filename):
    try:
        with FTP(FTP_HOST) as ftp:
            ftp.login(user=FTP_USER, passwd=FTP_PASS)
            ftp.cwd(FTP_TARGET_DIR)
            with open(local_file_path, "rb") as f:
                ftp.storbinary(f"STOR {remote_filename}", f)
        print(f"\U0001F680 File successfully uploaded to FTP: {remote_filename}")
    except Exception as e:
        print(f"‚ùå FTP upload failed: {e}")

def generate_fake_row(columns, types, date_format, start_year, end_year, entity_prc_values, fixed_lengths):
    row = []
    for col, typ in zip(columns, types):
        typ_lower = typ.lower()
        if "date" in typ_lower or "timestamp" in typ_lower:
            start_date = datetime(start_year, 1, 1)
            end_date = datetime(end_year, 12, 31)
            value = faker.date_time_between(start_date=start_date, end_date=end_date)
            row.append(value.strftime(date_format))
        elif col.upper() == "ENTITY_PRC" and entity_prc_values:
            row.append(faker.random_element(entity_prc_values))
        elif "int" in typ_lower:
            length = fixed_lengths.get(col)
            num = faker.random_int(min=0, max=10**length - 1) if length else faker.random_int(min=0, max=99999)
            row.append(str(num).zfill(length) if length else num)
        elif "float" in typ_lower or "decimal" in typ_lower:
            row.append(round(faker.pyfloat(left_digits=4, right_digits=2, positive=True), 2))
        elif "email" in col.lower():
            row.append(faker.email())
        elif "char" in typ_lower or "varchar" in typ_lower or "string" in typ_lower:
            val = faker.word()
            length = fixed_lengths.get(col)
            row.append(val[:length] if length else val)
        else:
            val = faker.word()
            length = fixed_lengths.get(col)
            row.append(val[:length] if length else val)
    return row

def generate_unique_data(columns, types, count, date_format, start_year, end_year, pk_indices, entity_prc_values, fixed_lengths):
    data = []
    seen_keys = set()
    attempts = 0
    max_attempts = count * 10

    while len(data) < count and attempts < max_attempts:
        row = generate_fake_row(columns, types, date_format, start_year, end_year, entity_prc_values, fixed_lengths)
        key = tuple(row[i] for i in pk_indices)
        if key not in seen_keys:
            seen_keys.add(key)
            data.append(row)
        attempts += 1

    if len(data) < count:
        print(f"‚ö†Ô∏è Warning: Only generated {len(data)} unique rows out of requested {count}.")
    return data

class ExcelHandler(FileSystemEventHandler):
    def on_created(self, event):
        if not event.is_directory and event.src_path.endswith(".xlsx"):
            file_path = event.src_path
            print(f"\nüì• New Excel file detected: {file_path}")
            try:
                columns, types = parse_excel(file_path)
                print(f"Columns: {columns}")
                print(f"Types: {types}")

                num_rows = int(input("üî¢ How many rows of data should be generated? "))
                date_format = input("üìÜ What date format should be used? (e.g. %Y-%m-%d, %d/%m/%Y): ")
                delimiter = input("üî£ What character should be used as a delimiter between rows? (e.g. ',' or ';' or '|'): ")
                start_year = int(input("üìÖ Start year for date fields? "))
                end_year = int(input("üìÖ End year for date fields? "))

                print("üóùÔ∏è Columns:")
                for idx, name in enumerate(columns):
                    print(f"{idx}: {name}")
                pk_input = input("üîë Enter comma-separated column numbers that form the Primary Key (e.g., 0,2): ")
                pk_indices = [int(i.strip()) for i in pk_input.split(",") if i.strip().isdigit()]

                entity_prc_values = []
                if "ENTITY_PRC" in columns:
                    raw = input("üè∑Ô∏è Enter comma-separated values for ENTITY_PRC: ")
                    entity_prc_values = [val.strip() for val in raw.split(",") if val.strip()]

                fixed_lengths = {}
                for col, typ in zip(columns, types):
                    if not any(x in typ.lower() for x in ["date", "timestamp"]):
                        val = input(f"üî¢ Enter fixed length for column '{col}' (or press Enter to skip): ")
                        if val.isdigit():
                            fixed_lengths[col] = int(val)

                output_name = input("üíæ Enter output filename (without extension), or press Enter to auto-name: ")
                base_filename = os.path.basename(file_path).replace(".xlsx", "")
                output_filename = (output_name if output_name else f"{base_filename}_out") + ".txt"
                output_path = os.path.join(OUTPUT_FOLDER, output_filename)

                print("ü§ñ Generating data...")
                rows = generate_unique_data(columns, types, num_rows, date_format, start_year, end_year, pk_indices, entity_prc_values, fixed_lengths)

                if not rows:
                    print("‚ùå No data generated. Skipping file.")
                    return

                df = pd.DataFrame(rows, columns=columns)
                df.to_csv(output_path, index=False, sep=delimiter, lineterminator="\n")
                print(f"‚úÖ Data saved to {output_path}")

                upload_via_ftp(output_path, output_filename)

            except Exception as e:
                print(f"‚ùå Error processing file: {e}")

def main():
    print(f"üìÇ Watching folder: {INPUT_FOLDER}")
    observer = Observer()
    observer.schedule(ExcelHandler(), INPUT_FOLDER, recursive=False)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

if __name__ == "__main__":
    main()
