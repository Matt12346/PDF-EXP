import os
import time
import pandas as pd
from faker import Faker
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from datetime import datetime
from dotenv import load_dotenv
from ftplib import FTP

load_dotenv()

INPUT_FOLDER = "./excel_drop"
OUTPUT_FOLDER = "./output_text"
FTP_HOST = "ftp.example.com"
FTP_USER = "username"
FTP_PASS = "password"

os.makedirs(INPUT_FOLDER, exist_ok=True)
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

faker = Faker()

def parse_excel(path):
    df = pd.read_excel(path, header=None)

    if df.shape[0] == 2 and df.shape[1] > 2:
        # Horizontal layout
        columns = df.iloc[0].tolist()
        types = df.iloc[1].tolist()
    elif df.shape[1] == 2 and df.shape[0] > 2:
        # Vertical layout
        columns = df.iloc[:, 0].tolist()
        types = df.iloc[:, 1].tolist()
    else:
        raise ValueError("‚ùå Input Excel must have either 2 rows or 2 columns to define schema.")

    return columns, types

def generate_fake_row(columns, types, date_format, start_year, end_year, fixed_lengths, entity_prc_values):
    row = []
    for col, typ in zip(columns, types):
        typ_lower = typ.lower()
        value = ""

        if "date" in typ_lower or "timestamp" in typ_lower:
            start_date = datetime(start_year, 1, 1)
            end_date = datetime(end_year, 12, 31)
            value = faker.date_between(start_date=start_date, end_date=end_date)
            if "timestamp" in typ_lower:
                value = value.strftime(f"{date_format} %H:%M:%S.%f")[:-3]  # milliseconds
            else:
                value = value.strftime(date_format)

        elif "int" in typ_lower or "smallint" in typ_lower or "bigint" in typ_lower:
            value = faker.random_int(min=0, max=99999)

        elif "float" in typ_lower or "decimal" in typ_lower:
            value = round(faker.pyfloat(left_digits=4, right_digits=2, positive=True), 2)

        elif "email" in col.lower():
            value = faker.email()

        elif "name" in col.lower():
            value = faker.name()

        elif "age" in col.lower():
            value = faker.random_int(min=0, max=100)

        elif col.upper() == "ENTITY_PRC" and entity_prc_values:
            value = faker.random_element(entity_prc_values)

        else:
            value = faker.word()

        # Apply fixed length
        if col.upper() not in ["ENTITY_PRC"] and ("date" not in typ_lower and "timestamp" not in typ_lower):
            max_len = fixed_lengths.get(col)
            if max_len and isinstance(value, str):
                value = value[:max_len].ljust(max_len, 'x')
            elif max_len and isinstance(value, int):
                value = str(value).zfill(max_len)
        row.append(value)
    return row

def generate_unique_data(columns, types, count, date_format, start_year, end_year, pk_indices, fixed_lengths, entity_prc_values):
    data = []
    seen_keys = set()
    attempts = 0
    max_attempts = count * 10

    while len(data) < count and attempts < max_attempts:
        row = generate_fake_row(columns, types, date_format, start_year, end_year, fixed_lengths, entity_prc_values)
        key = tuple(row[i] for i in pk_indices)
        if key not in seen_keys:
            seen_keys.add(key)
            data.append(row)
        attempts += 1

    if len(data) < count:
        print(f"‚ö†Ô∏è Warning: Only generated {len(data)} unique rows out of requested {count}.")
    return data

def upload_via_ftp(local_path, remote_path):
    try:
        with FTP(FTP_HOST) as ftp:
            ftp.login(FTP_USER, FTP_PASS)
            folders = remote_path.split("/")
            for folder in folders[:-1]:
                if folder not in ftp.nlst():
                    ftp.mkd(folder)
                ftp.cwd(folder)
            with open(local_path, "rb") as f:
                ftp.storbinary(f"STOR {folders[-1]}", f)
        print("‚úÖ File uploaded via FTP.")
    except Exception as e:
        print(f"‚ùå FTP upload failed: {e}")

class ExcelHandler(FileSystemEventHandler):
    def on_created(self, event):
        if not event.is_directory and event.src_path.endswith(".xlsx"):
            file_path = event.src_path
            print(f"\nüì• New Excel file detected: {file_path}")
            try:
                columns, types = parse_excel(file_path)
                print(f"Columns: {columns}")
                print(f"Types: {types}")

                num_rows = int(input("üî¢ How many rows of data should be generated? "))
                date_format = input("üìÜ What date format should be used? (e.g. %Y-%m-%d, %d/%m/%Y): ")
                start_year = int(input("üìÖ Start year for date fields? "))
                end_year = int(input("üìÖ End year for date fields? "))
                delimiter = input("üî£ What character should be used as a delimiter between rows? (e.g. ',' or ';' or '|'): ")

                fixed_lengths = {}
                for col, typ in zip(columns, types):
                    if "date" in typ.lower() or "timestamp" in typ.lower():
                        continue
                    fixed_len = input(f"üìè Enter max length for column '{col}' (press Enter to skip): ").strip()
                    if fixed_len.isdigit():
                        fixed_lengths[col] = int(fixed_len)

                entity_prc_values = []
                if "ENTITY_PRC" in columns:
                    input_vals = input("üè∑Ô∏è Enter values for ENTITY_PRC (comma-separated): ")
                    entity_prc_values = [val.strip() for val in input_vals.split(",") if val.strip()]

                print("üóùÔ∏è Columns:")
                for idx, name in enumerate(columns):
                    print(f"{idx}: {name}")
                pk_input = input("üîë Enter comma-separated column numbers that form the Primary Key (e.g., 0,2): ")
                pk_indices = [int(i.strip()) for i in pk_input.split(",") if i.strip().isdigit()]

                output_name = input("üíæ Enter custom name for output file (press Enter to auto-generate): ").strip()
                if not output_name:
                    base = os.path.basename(file_path).replace(".xlsx", "")
                    output_name = base + "_out"

                subfolder = input("üìÅ Do you want to place the file in a specific subfolder? (y/n): ").strip().lower()
                final_output_folder = OUTPUT_FOLDER
                if subfolder == "y":
                    subfolder_name = input("üìÅ Enter subfolder name: ").strip()
                    final_output_folder = os.path.join(OUTPUT_FOLDER, subfolder_name)
                    os.makedirs(final_output_folder, exist_ok=True)

                print("ü§ñ Generating data...")

                rows = generate_unique_data(columns, types, num_rows, date_format, start_year, end_year, pk_indices, fixed_lengths, entity_prc_values)

                if not rows:
                    print("‚ùå No data generated. Skipping file.")
                    return

                df = pd.DataFrame(rows, columns=columns)
                output_path = os.path.join(final_output_folder, output_name + ".txt")
                df.to_csv(output_path, index=False, sep=delimiter, lineterminator="\n")
                print(f"‚úÖ Data saved to {output_path}")

                transfer = input("üåê Do you want to transfer this file via FTP? (y/n): ").strip().lower()
                if transfer == "y":
                    remote_path = input("üåç Enter destination path on FTP server (e.g. uploads/data.txt): ")
                    upload_via_ftp(output_path, remote_path)

            except Exception as e:
                print(f"‚ùå Error processing file: {e}")

def main():
    print(f"üìÇ Watching folder: {INPUT_FOLDER}")
    observer = Observer()
    observer.schedule(ExcelHandler(), INPUT_FOLDER, recursive=False)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

if __name__ == "__main__":
    main()

