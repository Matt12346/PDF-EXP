import os
import time
import pandas as pd
from faker import Faker
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from datetime import datetime
from dotenv import load_dotenv
import ftplib

load_dotenv()

INPUT_FOLDER = "./excel_drop"
OUTPUT_FOLDER = "./output_text"
FTP_HOST = os.getenv("FTP_HOST")
FTP_USER = os.getenv("FTP_USER")
FTP_PASS = os.getenv("FTP_PASS")
FTP_DIR = os.getenv("FTP_DIR", "/")

os.makedirs(INPUT_FOLDER, exist_ok=True)
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

faker = Faker()

def parse_excel(path):
    df = pd.read_excel(path, header=None)
    if df.shape[0] >= 2 and df.shape[1] >= 2:
        if df.shape[0] == 2:
            # Two rows, multiple columns
            columns = df.iloc[0].tolist()
            types = df.iloc[1].tolist()
        else:
            # Two columns, multiple rows
            columns = df.iloc[:, 0].dropna().tolist()
            types = df.iloc[:, 1].dropna().tolist()
        return columns, types
    else:
        raise ValueError("Invalid Excel structure. Expected either 2 rows or 2 columns with data.")

def generate_fake_row(columns, types, date_format, start_year, end_year, fixed_values, fixed_lengths):
    row = []
    for col, typ in zip(columns, types):
        typ_lower = str(typ).lower()
        length = fixed_lengths.get(col)

        if col in fixed_values:
            value = faker.random_element(fixed_values[col])
        elif "date" in typ_lower or "timestamp" in typ_lower:
            start_date = datetime(start_year, 1, 1)
            end_date = datetime(end_year, 12, 31)
            value = faker.date_time_between(start_date=start_date, end_date=end_date)
            value = value.strftime(date_format)
        elif "int" in typ_lower or "smallint" in typ_lower or "bigint" in typ_lower:
            value = faker.random_int(min=0, max=99999)
        elif "float" in typ_lower or "decimal" in typ_lower:
            value = round(faker.pyfloat(left_digits=4, right_digits=2, positive=True), 2)
        elif "email" in col.lower():
            value = faker.email()
        elif "name" in col.lower():
            value = faker.name()
        elif "age" in col.lower():
            value = faker.random_int(min=0, max=100)
        else:
            value = faker.word()

        if length and isinstance(value, str):
            value = value[:length].ljust(length, 'x')

        row.append(value)
    return row

def generate_unique_data(columns, types, count, date_format, start_year, end_year, pk_indices, fixed_values, fixed_lengths):
    data = []
    seen_keys = set()
    attempts = 0
    max_attempts = count * 10

    while len(data) < count and attempts < max_attempts:
        row = generate_fake_row(columns, types, date_format, start_year, end_year, fixed_values, fixed_lengths)
        key = tuple(row[i] for i in pk_indices)
        if key not in seen_keys:
            seen_keys.add(key)
            data.append(row)
        attempts += 1

    if len(data) < count:
        print(f"âš ï¸ Warning: Only generated {len(data)} unique rows out of requested {count}.")
    return data

def upload_via_ftp(local_path, remote_dir, filename):
    with ftplib.FTP(FTP_HOST, FTP_USER, FTP_PASS) as ftp:
        ftp.cwd(FTP_DIR)
        if remote_dir:
            try:
                ftp.mkd(remote_dir)
            except:
                pass  # already exists
            ftp.cwd(remote_dir)
        with open(local_path, 'rb') as f:
            ftp.storbinary(f'STOR {filename}', f)
        print("ðŸ“¡ File uploaded via FTP.")

class ExcelHandler(FileSystemEventHandler):
    def on_created(self, event):
        print(f"ðŸ“¦ Detected a new file system event: {event.src_path}")

        if not event.is_directory and event.src_path.endswith(".xlsx"):
            print("ðŸ“„ Valid Excel file detected.")
            file_path = event.src_path
            print(f"\nðŸ“¥ Processing Excel file: {file_path}")
            try:
                columns, types = parse_excel(file_path)
                print(f"ðŸ§© Columns: {columns}")
                print(f"ðŸ“ Types: {types}")

                num_rows = int(input("ðŸ”¢ How many rows of data should be generated? "))
                date_format = input("ðŸ“† What date format should be used? (e.g. %Y-%m-%d, %d/%m/%Y): ")
                delimiter = input("ðŸ”£ What character should be used as a delimiter between rows? (e.g. ',' or ';' or '|'): ")
                start_year = int(input("ðŸ“… Start year for date fields? "))
                end_year = int(input("ðŸ“… End year for date fields? "))

                print("ðŸ—ï¸ Columns:")
                for idx, name in enumerate(columns):
                    print(f"{idx}: {name}")
                pk_input = input("ðŸ”‘ Enter comma-separated column numbers that form the Primary Key (e.g., 0,2): ")
                pk_indices = [int(i.strip()) for i in pk_input.split(",") if i.strip().isdigit()]

                fixed_values = {}
                for col in columns:
                    if col.strip().lower() == "entity_prc":
                        vals = input(f"ðŸ·ï¸ Enter comma-separated values to use for {col}: ").split(',')
                        fixed_values[col] = [v.strip() for v in vals if v.strip()]

                fixed_lengths = {}
                for col, typ in zip(columns, types):
                    if "date" not in typ.lower() and "timestamp" not in typ.lower():
                        length = input(f"ðŸ”  Enter fixed length for column '{col}' (or press Enter to skip): ").strip()
                        if length.isdigit():
                            fixed_lengths[col] = int(length)

                out_name = input("ðŸ’¾ Enter output file name (or press Enter to use input filename + '_out'): ").strip()
                if not out_name:
                    out_name = os.path.basename(file_path).replace(".xlsx", "_out.txt")
                if not out_name.endswith(".txt"):
                    out_name += ".txt"

                print("ðŸ¤– Generating data...")
                rows = generate_unique_data(columns, types, num_rows, date_format, start_year, end_year, pk_indices, fixed_values, fixed_lengths)
                if not rows:
                    print("âŒ No data generated. Skipping file.")
                    return

                df = pd.DataFrame(rows, columns=columns)
                output_path = os.path.join(OUTPUT_FOLDER, out_name)
                df.to_csv(output_path, index=False, sep=delimiter, lineterminator="\n")
                print(f"âœ… Data saved to {output_path}")

                if input("ðŸš€ Transfer this file via FTP? (y/n): ").lower().strip() == 'y':
                    subfolder = input("ðŸ“ Enter subfolder on FTP (leave blank to skip): ").strip()
                    upload_via_ftp(output_path, subfolder, out_name)

            except Exception as e:
                print(f"âŒ Error processing file: {e}")
        else:
            print("â— Ignored event: not a valid Excel file (.xlsx)")

def main():
    print(f"ðŸ“‚ Watching folder: {os.path.abspath(INPUT_FOLDER)}")
    observer = Observer()
    observer.schedule(ExcelHandler(), INPUT_FOLDER, recursive=False)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

if __name__ == "__main__":
    main()

